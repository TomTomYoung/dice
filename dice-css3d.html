<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CSS3Dã‚µã‚¤ã‚³ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
<style>
  :root {
    --size: 94px;
    --pip: 14px;
    --gap: 16px;
  }
  * {
    box-sizing: border-box;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    margin: 0;
    padding: 24px;
    background: linear-gradient(160deg, #eef2ff, #c7d2fe 60%, #e0f2fe);
    color: #0f172a;
  }
  .container {
    max-width: 1200px;
    margin: 0 auto;
  }
  header {
    background: white;
    padding: 32px;
    border-radius: 20px;
    margin-bottom: 24px;
    box-shadow: 0 28px 64px rgba(99, 102, 241, .24);
  }
  h1 {
    margin: 0 0 12px;
    font-size: 32px;
    font-weight: 700;
  }
  .lead {
    margin: 0;
    color: #475569;
    font-size: 15px;
  }
  .config-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-bottom: 24px;
  }
  .config-group {
    background: white;
    padding: 20px;
    border-radius: 16px;
    border: 1px solid rgba(99, 102, 241, .12);
    box-shadow: 0 10px 32px rgba(79, 70, 229, .12);
  }
  .config-group h3 {
    margin: 0 0 14px;
    font-size: 15px;
    font-weight: 700;
    color: #4338ca;
    letter-spacing: .4px;
  }
  .form-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }
  .form-row label {
    min-width: 110px;
    font-size: 14px;
    color: #475569;
  }
  .form-row input[type="number"],
  .form-row input[type="color"],
  .form-row input[type="range"],
  .form-row select {
    flex: 1;
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid #c7d2fe;
    font-size: 14px;
    background: #f8fafc;
  }
  .form-row input[type="range"] {
    padding: 0;
    height: 6px;
  }
  .radio-group,
  .checkbox-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .radio-item,
  .checkbox-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px;
    border-radius: 10px;
    transition: background .15s ease;
  }
  .radio-item:hover,
  .checkbox-item:hover {
    background: rgba(99,102,241,.08);
  }
  .inline-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 10px;
  }
  .inline-grid label {
    display: flex;
    flex-direction: column;
    font-size: 13px;
    color: #475569;
  }
  .inline-grid input {
    margin-top: 4px;
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid #cbd5f5;
  }
  .dice-container {
    background: white;
    padding: 36px;
    border-radius: 20px;
    box-shadow: 0 26px 60px rgba(59, 130, 246, 0.18);
    min-height: 260px;
  }
  .board-3d {
    display: flex;
    gap: var(--gap);
    perspective: 1200px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .die-wrap-3d {
    width: var(--size);
    height: var(--size);
    position: relative;
  }
  .cube {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
  }
  .face {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    background: linear-gradient(145deg, #f8fafc, #e2e8f0);
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, .7);
    box-shadow: inset 0 0 12px rgba(15,23,42,.12);
    overflow: hidden;
  }
  .face-content {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
  }
  .face-label {
    grid-column: 1 / -1;
    grid-row: 1 / -1;
    display: grid;
    place-items: center;
    font-size: 34px;
    font-weight: 700;
    color: #0f172a;
    text-shadow: 0 1px 3px rgba(255,255,255,0.7);
  }
  .face-label.textual {
    font-size: 30px;
    letter-spacing: .12em;
  }
  .face-label.small {
    font-size: 26px;
  }
  .pip {
    width: var(--pip);
    height: var(--pip);
    background: #0f172a;
    border-radius: 50%;
    margin: auto;
  }
  .p1 { grid-area: 1 / 1; }
  .p2 { grid-area: 1 / 2; }
  .p3 { grid-area: 1 / 3; }
  .p4 { grid-area: 2 / 1; }
  .p5 { grid-area: 2 / 2; }
  .p6 { grid-area: 2 / 3; }
  .p7 { grid-area: 3 / 1; }
  .p8 { grid-area: 3 / 2; }
  .p9 { grid-area: 3 / 3; }
  .f-front  { transform: translateZ(calc(var(--size) / 2)); }
  .f-back   { transform: rotateY(180deg) translateZ(calc(var(--size) / 2)); }
  .f-right  { transform: rotateY(90deg) translateZ(calc(var(--size) / 2)); }
  .f-left   { transform: rotateY(-90deg) translateZ(calc(var(--size) / 2)); }
  .f-top    { transform: rotateX(90deg) translateZ(calc(var(--size) / 2)); }
  .f-bottom { transform: rotateX(-90deg) translateZ(calc(var(--size) / 2)); }
  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 20px;
  }
  button {
    padding: 12px 24px;
    font-size: 15px;
    font-weight: 600;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    transition: transform .15s, box-shadow .15s;
  }
  .btn-primary {
    background: linear-gradient(135deg, #6366f1, #4338ca);
    color: white;
    box-shadow: 0 12px 32px rgba(79,70,229,.28);
  }
  .btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 16px 38px rgba(79,70,229,.32);
  }
  .btn-primary:disabled {
    background: #94a3b8;
    box-shadow: none;
    cursor: not-allowed;
  }
  .btn-secondary {
    background: #0f172a;
    color: white;
  }
  .btn-secondary:hover {
    transform: translateY(-1px);
  }
  .results {
    margin-top: 20px;
    padding: 18px;
    background: #eef2ff;
    border-radius: 14px;
    border: 1px solid #c7d2fe;
    color: #312e81;
    font-size: 15px;
    display: none;
  }
  .results-detail {
    margin-top: 4px;
    font-size: 14px;
    color: #3730a3;
  }
  .debug-controls {
    margin-top: 12px;
    padding: 12px;
    background: #fef3c7;
    border-radius: 10px;
    border: 1px solid #fcd34d;
    display: none;
  }
  .debug-controls label {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 8px;
    display: block;
  }
  .debug-inputs {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .debug-inputs input {
    width: 60px;
    padding: 4px 8px;
    border: 1px solid #d0d0d0;
    border-radius: 6px;
    text-align: center;
  }
  .note-box {
    font-size: 12px;
    color: #475569;
    background: rgba(148,163,184,0.2);
    padding: 10px 12px;
    border-radius: 10px;
  }
  @media (max-width: 640px) {
    .form-row {
      flex-direction: column;
      align-items: flex-start;
    }
    .form-row label {
      min-width: 0;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸ§Š CSS3Dã‚µã‚¤ã‚³ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
      <p class="lead">CSS3Dã«ã‚ˆã‚‹è»½é‡ãªæ“¬ä¼¼3Dè¡¨ç¾ã€‚æ¼”å‡ºã¨å¤–è¦³ã‚’ç´°éƒ¨ã¾ã§ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã§ãã¾ã™ã€‚</p>
    </header>

    <section class="config-panel">
      <div class="config-group">
        <h3>æç”»è¨­å®š</h3>
        <div class="radio-group">
          <div class="radio-item">
            <input type="radio" name="algorithm" id="algValue" value="value-first" checked>
            <label for="algValue">å‡ºç›®å…ˆè¡Œ (é«˜é€Ÿãƒ»æ­£ç¢º)</label>
          </div>
          <div class="radio-item">
            <input type="radio" name="algorithm" id="algVisual" value="visual-first">
            <label for="algVisual">æ¼”å‡ºå…ˆè¡Œ (è¦–è¦šé‡è¦–)</label>
          </div>
        </div>
      </div>

      <div class="config-group">
        <h3>ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</h3>
        <div class="form-row">
          <label for="diceCount">å€‹æ•°</label>
          <input type="number" id="diceCount" min="1" max="12" value="3">
        </div>
        <div class="form-row">
          <label for="spinCount">å›è»¢æ•°</label>
          <input type="number" id="spinCount" min="2" max="8" value="4">
        </div>
        <div class="form-row">
          <label for="duration">æ™‚é–“(ç§’)</label>
          <input type="number" id="duration" min="0.5" max="3.0" step="0.1" value="1.2">
        </div>
        <div class="radio-group">
          <div class="radio-item">
            <input type="radio" name="stop3d" id="stopFree" value="free">
            <label for="stopFree">ãƒ•ãƒªãƒ¼ã‚¹ãƒˆãƒƒãƒ—</label>
          </div>
          <div class="radio-item">
            <input type="radio" name="stop3d" id="stopSnap" value="snap" checked>
            <label for="stopSnap">ãƒ“ã‚¿æ­¢ã‚</label>
          </div>
        </div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="debugMode">
            <label for="debugMode">ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰</label>
          </div>
        </div>
      </div>

      <div class="config-group">
        <h3>å¤–è¦³è¨­å®š</h3>
        <div class="form-row">
          <label for="faceMode">å‡ºç›®ã®è¡¨ç¤º</label>
          <select id="faceMode">
            <option value="pips">ãƒ”ãƒƒãƒ—</option>
            <option value="number">æ•°å­—</option>
            <option value="text">æ–‡å­—</option>
            <option value="image">ç”»åƒ</option>
          </select>
        </div>
        <div class="form-row">
          <label for="bodyColor">ã‚µã‚¤ã®è‰²</label>
          <input type="color" id="bodyColor" value="#f5f7ff">
        </div>
        <div class="form-row">
          <label for="detailColor">ãƒ”ãƒƒãƒ—/æ–‡å­—è‰²</label>
          <input type="color" id="detailColor" value="#111827">
        </div>
        <div class="form-row">
          <label for="borderColor">ã‚¨ãƒƒã‚¸è‰²</label>
          <input type="color" id="borderColor" value="#c7d2fe">
        </div>
        <div class="form-row">
          <label for="cornerRadius">é¢ã®è§’</label>
          <input type="range" id="cornerRadius" min="0" max="30" value="16">
        </div>
      </div>

      <div class="config-group" id="textConfig" style="display:none;">
        <h3>æ–‡å­—è¡¨ç¤º</h3>
        <div class="inline-grid">
          <label>1ã®é¢
            <input type="text" data-face="1" class="text-entry" value="å£±">
          </label>
          <label>2ã®é¢
            <input type="text" data-face="2" class="text-entry" value="å¼">
          </label>
          <label>3ã®é¢
            <input type="text" data-face="3" class="text-entry" value="å‚">
          </label>
          <label>4ã®é¢
            <input type="text" data-face="4" class="text-entry" value="è‚†">
          </label>
          <label>5ã®é¢
            <input type="text" data-face="5" class="text-entry" value="ä¼">
          </label>
          <label>6ã®é¢
            <input type="text" data-face="6" class="text-entry" value="é™¸">
          </label>
        </div>
        <p class="note-box">ç©ºæ¬„ã®é¢ã¯æ•°å­—ã§è£œå®Œã•ã‚Œã¾ã™ã€‚</p>
      </div>

      <div class="config-group" id="imageConfig" style="display:none;">
        <h3>ç”»åƒè¡¨ç¤º</h3>
        <div class="inline-grid">
          <label>1ã®é¢
            <input type="text" data-face="1" class="image-entry" placeholder="ç”»åƒURL">
          </label>
          <label>2ã®é¢
            <input type="text" data-face="2" class="image-entry" placeholder="ç”»åƒURL">
          </label>
          <label>3ã®é¢
            <input type="text" data-face="3" class="image-entry" placeholder="ç”»åƒURL">
          </label>
          <label>4ã®é¢
            <input type="text" data-face="4" class="image-entry" placeholder="ç”»åƒURL">
          </label>
          <label>5ã®é¢
            <input type="text" data-face="5" class="image-entry" placeholder="ç”»åƒURL">
          </label>
          <label>6ã®é¢
            <input type="text" data-face="6" class="image-entry" placeholder="ç”»åƒURL">
          </label>
        </div>
        <p class="note-box">ç”»åƒãŒæœªæŒ‡å®šã®é¢ã¯æ•°å­—ã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
      </div>

      <div class="config-group debug-controls" id="debugControls">
        <h3>ãƒ‡ãƒãƒƒã‚°è¨­å®š</h3>
        <label for="debugValues">å‡ºç›® (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã€1-6)</label>
        <div class="debug-inputs">
          <input type="text" id="debugValues" placeholder="ä¾‹: 6,6,6">
        </div>
      </div>
    </section>

    <section class="dice-container">
      <div id="diceBoard" class="board-3d"></div>
      <div class="actions">
        <button id="rollBtn" class="btn-primary">ãƒ­ãƒ¼ãƒ«ã™ã‚‹ (Space)</button>
        <button id="resetBtn" class="btn-secondary">ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
      <div id="results" class="results"></div>
    </section>
  </div>

<script>
(() => {
  const diceBoard = document.getElementById('diceBoard');
  const resultsEl = document.getElementById('results');
  const rollBtn = document.getElementById('rollBtn');
  const resetBtn = document.getElementById('resetBtn');
  const diceCountInput = document.getElementById('diceCount');
  const spinCountInput = document.getElementById('spinCount');
  const durationInput = document.getElementById('duration');
  const debugModeCheck = document.getElementById('debugMode');
  const debugControls = document.getElementById('debugControls');
  const debugValuesInput = document.getElementById('debugValues');
  const algValue = document.getElementById('algValue');
  const algVisual = document.getElementById('algVisual');
  const stopFree = document.getElementById('stopFree');
  const stopSnap = document.getElementById('stopSnap');
  const bodyColorInput = document.getElementById('bodyColor');
  const detailColorInput = document.getElementById('detailColor');
  const borderColorInput = document.getElementById('borderColor');
  const cornerRadiusInput = document.getElementById('cornerRadius');
  const faceModeSelect = document.getElementById('faceMode');
  const textConfig = document.getElementById('textConfig');
  const imageConfig = document.getElementById('imageConfig');
  const textEntries = Array.from(document.querySelectorAll('.text-entry'));
  const imageEntries = Array.from(document.querySelectorAll('.image-entry'));

  const facesDef = [
    { cls: 'f-front',  value: 1, pips: [5] },
    { cls: 'f-back',   value: 6, pips: [1, 3, 4, 6, 7, 9] },
    { cls: 'f-right',  value: 3, pips: [1, 5, 9] },
    { cls: 'f-left',   value: 4, pips: [1, 3, 7, 9] },
    { cls: 'f-top',    value: 5, pips: [1, 3, 5, 7, 9] },
    { cls: 'f-bottom', value: 2, pips: [1, 9] }
  ];

  const ORIENT_3D = {
    1: { x: 0,   y: 0,   z: 0 },
    2: { x: 90,  y: 0,   z: 0 },
    3: { x: 0,   y: -90, z: 0 },
    4: { x: 0,   y: 90,  z: 0 },
    5: { x: -90, y: 0,   z: 0 },
    6: { x: 0,   y: 180, z: 0 }
  };

  const appearance = {
    bodyColor: bodyColorInput.value,
    detailColor: detailColorInput.value,
    borderColor: borderColorInput.value,
    cornerRadius: Number(cornerRadiusInput.value),
    faceMode: faceModeSelect.value,
    texts: ['å£±','å¼','å‚','è‚†','ä¼','é™¸'],
    images: ['', '', '', '', '', '']
  };

  const state = {
    diceCount: Number(diceCountInput.value) || 3,
    spinCount: Number(spinCountInput.value) || 4,
    duration: Number(durationInput.value) || 1.2,
    algorithm: 'value-first',
    stop3d: 'snap',
    diceElements: [],
    isRolling: false,
    debugMode: false
  };

  function randint1n(n) {
    if (crypto?.getRandomValues) {
      const max = 0xFFFFFFFF;
      const limit = Math.floor(max / n) * n;
      const buf = new Uint32Array(1);
      for (;;) {
        crypto.getRandomValues(buf);
        if (buf[0] < limit) return (buf[0] % n) + 1;
      }
    }
    return Math.floor(Math.random() * n) + 1;
  }

  function getPipPositions(value) {
    const map = {
      1: [5],
      2: [1, 9],
      3: [1, 5, 9],
      4: [1, 3, 7, 9],
      5: [1, 3, 5, 7, 9],
      6: [1, 3, 4, 6, 7, 9]
    };
    return map[value] || [5];
  }

  function mixColor(hex, weight, target) {
    if (!/^#([0-9a-fA-F]{6})$/.test(hex)) return hex;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    const tr = parseInt(target.slice(1, 3), 16);
    const tg = parseInt(target.slice(3, 5), 16);
    const tb = parseInt(target.slice(5, 7), 16);
    const blend = (c, t) => Math.round(c * (1 - weight) + t * weight);
    return `#${blend(r, tr).toString(16).padStart(2, '0')}${blend(g, tg).toString(16).padStart(2, '0')}${blend(b, tb).toString(16).padStart(2, '0')}`;
  }

  function faceGradient(base) {
    const light = mixColor(base, 0.25, '#ffffff');
    const dark = mixColor(base, 0.25, '#000000');
    return `linear-gradient(145deg, ${light}, ${dark})`;
  }

  function createDie3D() {
    const wrap = document.createElement('div');
    wrap.className = 'die-wrap-3d';
    const cube = document.createElement('div');
    cube.className = 'cube';
    wrap.appendChild(cube);

    const faces = facesDef.map(f => {
      const face = document.createElement('div');
      face.className = `face ${f.cls}`;
      face.dataset.value = f.value;
      const content = document.createElement('div');
      content.className = 'face-content';
      face.appendChild(content);
      cube.appendChild(face);
      return { face, content, value: f.value, pips: f.pips };
    });

    return { wrap, cube, faces };
  }

  function applyFaceStyle(faceObj) {
    const { face } = faceObj;
    face.style.background = faceGradient(appearance.bodyColor);
    face.style.border = `1px solid ${appearance.borderColor}`;
    face.style.borderRadius = `${appearance.cornerRadius}px`;
  }

  function renderFace(faceObj, value) {
    const { face, content, pips } = faceObj;
    face.classList.remove('has-image');
    face.style.backgroundImage = '';
    content.innerHTML = '';

    if (appearance.faceMode === 'pips') {
      content.style.display = 'grid';
      pips.forEach(pos => {
        const pip = document.createElement('div');
        pip.className = `pip p${pos}`;
        pip.style.background = appearance.detailColor;
        content.appendChild(pip);
      });
    } else if (appearance.faceMode === 'number') {
      content.style.display = 'grid';
      const label = document.createElement('div');
      label.className = 'face-label';
      label.textContent = String(value);
      label.style.color = appearance.detailColor;
      content.appendChild(label);
    } else if (appearance.faceMode === 'text') {
      content.style.display = 'grid';
      const label = document.createElement('div');
      label.className = 'face-label textual';
      const text = appearance.texts[value - 1] || String(value);
      label.textContent = text;
      label.style.color = appearance.detailColor;
      content.appendChild(label);
    } else if (appearance.faceMode === 'image') {
      const url = appearance.images[value - 1]?.trim();
      if (url) {
        face.classList.add('has-image');
        face.style.backgroundImage = `linear-gradient(145deg, rgba(15,23,42,0.1), rgba(15,23,42,0.25)), url(${url})`;
        face.style.backgroundSize = 'cover';
        face.style.backgroundPosition = 'center';
        const overlay = document.createElement('div');
        overlay.className = 'face-label small';
        overlay.textContent = '';
        content.appendChild(overlay);
      } else {
        const label = document.createElement('div');
        label.className = 'face-label small';
        label.textContent = String(value);
        label.style.color = appearance.detailColor;
        content.appendChild(label);
      }
    }

    face.setAttribute('data-value', value);
  }

  function applyAppearance(dieObj) {
    dieObj.faces.forEach(faceObj => {
      applyFaceStyle(faceObj);
      const value = Number(faceObj.face.getAttribute('data-value')) || faceObj.value;
      renderFace(faceObj, value);
    });
  }

  function initBoard() {
    diceBoard.innerHTML = '';
    state.diceElements = [];
    resultsEl.style.display = 'none';

    for (let i = 0; i < state.diceCount; i++) {
      const die = createDie3D();
      die.cube.style.transform = 'rotateX(-20deg) rotateY(30deg)';
      diceBoard.appendChild(die.wrap);
      state.diceElements.push(die);
      applyAppearance(die);
    }
  }

  function getTargetValues() {
    if (state.debugMode) {
      const input = debugValuesInput.value.trim();
      if (input) {
        const parsed = input.split(',').map(v => {
          const n = parseInt(v.trim(), 10);
          return (n >= 1 && n <= 6) ? n : randint1n(6);
        });
        while (parsed.length < state.diceCount) {
          parsed.push(randint1n(6));
        }
        return parsed.slice(0, state.diceCount);
      }
    }
    return Array.from({ length: state.diceCount }, () => randint1n(6));
  }

  function showResults(values, total) {
    resultsEl.style.display = 'block';
    resultsEl.innerHTML = `
      <div>åˆè¨ˆ: <strong>${total}</strong></div>
      <div class="results-detail">å‡ºç›®: ${values.join(', ')}</div>
    `;
  }

  function refreshAppearance() {
    state.diceElements.forEach(die => {
      die.faces.forEach(faceObj => {
        applyFaceStyle(faceObj);
        const value = Number(faceObj.face.getAttribute('data-value')) || faceObj.value;
        renderFace(faceObj, value);
      });
    });
  }

  function roll3DValueFirst() {
    const values = getTargetValues();
    const useSnap = state.stop3d === 'snap';
    let remaining = state.diceElements.length;
    let total = 0;

    state.diceElements.forEach((die, idx) => {
      const cube = die.cube;
      cube.style.transition = 'none';
      cube.style.transform = 'rotateX(-20deg) rotateY(30deg)';
      void cube.offsetWidth;

      const v = values[idx];
      total += v;
      const base = ORIENT_3D[v];
      const spins = state.spinCount;
      const rx = base.x + spins * 360 + (Math.random() * 10 - 5);
      const ry = base.y + spins * 360 + (Math.random() * 10 - 5);
      const rz = useSnap ? 0 : (Math.random() * 20 - 10);

      cube.style.transition = `transform ${state.duration}s cubic-bezier(.25,1,.3,1)`;
      cube.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`;

      const onEnd = () => {
        cube.removeEventListener('transitionend', onEnd);
        if (useSnap) {
          cube.style.transition = 'none';
          cube.style.transform = `rotateX(${base.x}deg) rotateY(${base.y}deg) rotateZ(0deg)`;
        }
        die.faces.forEach(faceObj => {
          renderFace(faceObj, Number(faceObj.face.dataset.value));
        });
        remaining--;
        if (remaining === 0) {
          showResults(values, total);
          state.isRolling = false;
          rollBtn.disabled = false;
        }
      };
      cube.addEventListener('transitionend', onEnd);

      die.faces.forEach(faceObj => {
        if (Number(faceObj.face.dataset.value) === v) {
          renderFace(faceObj, v);
        }
      });
    });
  }

  function roll3DVisualFirst() {
    const values = getTargetValues();
    let remaining = state.diceElements.length;
    let total = 0;

    state.diceElements.forEach((die, idx) => {
      const cube = die.cube;
      const v = values[idx];
      total += v;
      const base = ORIENT_3D[v];
      const spins = state.spinCount;
      const rx = base.x + spins * 360 + (Math.random() * 20 - 10);
      const ry = base.y + spins * 360 + (Math.random() * 20 - 10);
      const rz = Math.random() * 180 - 90;

      cube.style.transition = `transform ${state.duration}s cubic-bezier(.2,.7,.2,1)`;
      cube.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`;

      const onEnd = () => {
        cube.removeEventListener('transitionend', onEnd);
        remaining--;
        if (remaining === 0) {
          showResults(values, total);
          state.isRolling = false;
          rollBtn.disabled = false;
        }
      };
      cube.addEventListener('transitionend', onEnd);

      die.faces.forEach(faceObj => {
        if (Number(faceObj.face.dataset.value) === v) {
          renderFace(faceObj, v);
        }
      });
    });
  }

  function executeRoll() {
    if (state.isRolling) return;
    state.isRolling = true;
    rollBtn.disabled = true;

    if (state.algorithm === 'value-first') {
      roll3DValueFirst();
    } else {
      roll3DVisualFirst();
    }
  }

  rollBtn.addEventListener('click', executeRoll);
  resetBtn.addEventListener('click', () => {
    state.isRolling = false;
    rollBtn.disabled = false;
    initBoard();
  });

  ;[algValue, algVisual].forEach(input => {
    input.addEventListener('change', (e) => {
      state.algorithm = e.target.value;
    });
  });

  ;[stopFree, stopSnap].forEach(input => {
    input.addEventListener('change', (e) => {
      state.stop3d = e.target.value;
    });
  });

  diceCountInput.addEventListener('change', (e) => {
    const next = Math.max(1, Math.min(12, parseInt(e.target.value, 10) || 1));
    state.diceCount = next;
    diceCountInput.value = next;
    initBoard();
  });

  spinCountInput.addEventListener('change', (e) => {
    const next = Math.max(2, Math.min(8, parseInt(e.target.value, 10) || state.spinCount));
    state.spinCount = next;
    spinCountInput.value = next;
  });

  durationInput.addEventListener('change', (e) => {
    const next = Math.max(0.5, Math.min(3.0, parseFloat(e.target.value) || state.duration));
    state.duration = next;
    durationInput.value = next;
  });

  debugModeCheck.addEventListener('change', (e) => {
    state.debugMode = e.target.checked;
    debugControls.style.display = state.debugMode ? 'block' : 'none';
  });

  bodyColorInput.addEventListener('input', (e) => {
    appearance.bodyColor = e.target.value;
    refreshAppearance();
  });

  detailColorInput.addEventListener('input', (e) => {
    appearance.detailColor = e.target.value;
    refreshAppearance();
  });

  borderColorInput.addEventListener('input', (e) => {
    appearance.borderColor = e.target.value;
    refreshAppearance();
  });

  cornerRadiusInput.addEventListener('input', (e) => {
    appearance.cornerRadius = Number(e.target.value) || 0;
    refreshAppearance();
  });

  faceModeSelect.addEventListener('change', (e) => {
    appearance.faceMode = e.target.value;
    textConfig.style.display = appearance.faceMode === 'text' ? 'block' : 'none';
    imageConfig.style.display = appearance.faceMode === 'image' ? 'block' : 'none';
    refreshAppearance();
  });

  textEntries.forEach(input => {
    input.addEventListener('input', (e) => {
      const face = Number(e.target.dataset.face) || 1;
      appearance.texts[face - 1] = e.target.value;
      if (appearance.faceMode === 'text') {
        refreshAppearance();
      }
    });
  });

  imageEntries.forEach(input => {
    input.addEventListener('change', (e) => {
      const face = Number(e.target.dataset.face) || 1;
      appearance.images[face - 1] = e.target.value;
      if (appearance.faceMode === 'image') {
        refreshAppearance();
      }
    });
  });

  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      executeRoll();
    }
  });

  textConfig.style.display = appearance.faceMode === 'text' ? 'block' : 'none';
  imageConfig.style.display = appearance.faceMode === 'image' ? 'block' : 'none';

  initBoard();
})();
</script>
</body>
</html>
