<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚¹ãƒ­ãƒƒãƒˆãƒã‚·ãƒ³ï¼ˆæ‹¡å¼µç‰ˆï¼‰</title>
<style>
  :root {
    --bg:#06070d; --fg:#f8fafc; --muted:#94a3b8; --acc:#7aa2f7; --acc2:#f5b97f;
    --card:#111522; --border:#1f2937; --radius:14px;
    --reel-w:120px; --reel-h:168px;
  }
  @media (max-width: 720px) {
    :root { --reel-w:96px; --reel-h:140px; }
  }
  @media (max-width: 540px) {
    :root { --reel-w:82px; --reel-h:120px; }
  }
  html,body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.6 "Segoe UI",system-ui,"Hiragino Sans","Noto Sans JP",sans-serif; }
  h1 { font-size:1.8rem; margin:0 0 6px; letter-spacing:0.04em; }
  .app { max-width:1100px; margin:20px auto 48px; padding:0 18px 32px; }
  .layout { display:grid; gap:18px; grid-template-columns:1.35fr 1fr; }
  @media (max-width: 960px) {
    .layout { grid-template-columns:1fr; }
  }
  .card { background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:18px 20px; position:relative; overflow:hidden; }
  .card h2 { margin:0 0 10px; font-size:1.15rem; letter-spacing:0.03em; }
  .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  .controls label { display:flex; gap:6px; align-items:center; background:rgba(15,23,42,.35); padding:6px 10px; border-radius:12px; border:1px solid rgba(148,163,184,.12); }
  .controls select,
  .controls button,
  .controls input { background:#0d121d; border:1px solid rgba(148,163,184,.22); color:var(--fg); padding:6px 10px; border-radius:10px; font:inherit; }
  .controls button { cursor:pointer; transition:transform .2s ease, box-shadow .2s ease; }
  .controls button:not(:disabled):hover { transform:translateY(-1px); box-shadow:0 8px 18px rgba(122,162,247,.18); }
  .controls button:disabled { opacity:.45; cursor:not-allowed; }
  .stage { position:relative; border-radius:20px; border:1px solid rgba(148,163,184,.18); padding:28px 18px 34px; background:radial-gradient(circle at 50% 20%, rgba(124,165,255,.18), transparent 62%), linear-gradient(135deg, #0c111d 10%, #151c2b 55%, #0b0f19 100%); box-shadow:0 0 35px rgba(10,12,18,.8), 0 18px 34px rgba(8,10,16,.35); }
  .stage::before { content:""; position:absolute; inset:-20%; background:radial-gradient(circle, rgba(255,255,255,.12), transparent 66%); opacity:.12; transform:scale(1.4); z-index:0; animation:spotlight 5s ease-in-out infinite; }
  @keyframes spotlight {
    0%,100% { transform:translate(-6%, -4%) scale(1.4); opacity:.12; }
    50% { transform:translate(6%, 4%) scale(1.45); opacity:.2; }
  }
  .slots { position:relative; display:flex; flex-direction:column; align-items:center; gap:18px; z-index:2; }
  .slot-row { display:flex; justify-content:center; gap:22px; width:100%; }
  .reel-wrap { width:var(--reel-w); height:var(--reel-h); border-radius:16px; overflow:hidden; position:relative; background:linear-gradient(#04060b,#111625); box-shadow:inset 0 0 0 1px rgba(122,162,247,.06), 0 14px 40px rgba(0,0,0,.55); }
  .reel-wrap::after { content:""; position:absolute; inset:0; pointer-events:none; background:linear-gradient(to bottom, rgba(2,3,5,.85), transparent 28%, transparent 72%, rgba(3,5,9,.82)); }
  .reel { width:100%; height:100%; position:relative; transform-style:preserve-3d; will-change:transform; }
  .face { position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; font-size:2rem; font-weight:700; letter-spacing:1px; color:#f9fafb; text-shadow:0 2px 6px rgba(0,0,0,.5); background:radial-gradient(115% 120% at 50% -15%, rgba(124,165,255,.65), rgba(20,28,46,1) 58%); border-radius:16px; border:1px solid rgba(148,163,184,.16); box-shadow:inset 0 1px 0 rgba(255,255,255,.1), 0 12px 24px rgba(5,9,16,.65); backface-visibility:hidden; transition:transform .3s ease, box-shadow .3s ease; }
  .face small { font-size:.75rem; color:rgba(241,245,249,.78); text-transform:uppercase; letter-spacing:.2em; }
  .face.winning { animation:glow .7s ease-in-out infinite alternate; box-shadow:0 0 24px rgba(124,165,255,.85); }
  @keyframes glow { from { filter:drop-shadow(0 0 12px rgba(124,165,255,.55)); } to { filter:drop-shadow(0 0 26px rgba(245,185,127,.8)); } }
  .arm-line { position:absolute; left:22px; right:22px; top:50%; height:0; border-top:2px dashed rgba(122,162,247,.18); z-index:1; }
  .result { margin-top:18px; text-align:center; font-size:1.05rem; letter-spacing:.03em; min-height:1.2em; }
  .credits { display:flex; gap:22px; align-items:center; flex-wrap:wrap; font-size:1.05rem; }
  .credits strong { font-size:1.3rem; color:var(--acc); }
  .panel { display:flex; flex-direction:column; gap:12px; }
  .panel .row { display:flex; flex-wrap:wrap; gap:10px 14px; align-items:center; }
  textarea { background:#0d121d; border:1px solid rgba(148,163,184,.25); color:var(--fg); border-radius:12px; padding:10px 12px; font:inherit; line-height:1.5; }
  textarea:focus { outline:2px solid rgba(122,162,247,.45); outline-offset:2px; }
  .paytable { display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:10px; }
  .paytable div { background:rgba(15,23,42,.6); padding:10px; border-radius:12px; border:1px solid rgba(122,162,247,.18); box-shadow:inset 0 1px 0 rgba(255,255,255,.05); }
  .paytable h3 { margin:0 0 4px; font-size:.95rem; color:var(--acc2); }
  .paytable ul { margin:0; padding-left:18px; color:var(--muted); font-size:.85rem; }
  .hands { display:flex; flex-direction:column; gap:8px; }
  .hands-item { background:rgba(15,23,42,.6); padding:10px 12px; border-radius:12px; border:1px solid rgba(122,162,247,.16); }
  .hands-item strong { display:block; color:var(--acc2); font-size:.95rem; }
  .hands-item span { display:block; margin-top:4px; color:var(--muted); font-size:.85rem; }
  .history { max-height:220px; overflow:auto; border-radius:12px; border:1px solid rgba(148,163,184,.12); background:rgba(8,11,19,.55); padding:10px 12px; font-size:.9rem; }
  .history ul { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
  .history li { display:flex; justify-content:space-between; gap:12px; background:rgba(14,20,33,.6); padding:8px 10px; border-radius:10px; border:1px solid rgba(122,162,247,.14); }
  .history span.win { color:#facc15; font-weight:600; }
  .stats { display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:10px; }
  .stat { background:rgba(15,23,42,.6); border-radius:12px; padding:10px 12px; border:1px solid rgba(122,162,247,.12); }
  .stat dt { font-size:.75rem; text-transform:uppercase; letter-spacing:.16em; color:var(--muted); }
  .stat dd { margin:4px 0 0; font-size:1.05rem; font-weight:600; }
  .stop-buttons { margin-top:18px; display:flex; justify-content:center; gap:12px; flex-wrap:wrap; }
  .stop-buttons button { min-width:96px; }
  .autoplay-indicator { margin-left:auto; color:var(--acc2); font-size:.9rem; }
  .muted { color:var(--muted); }
  #announce { position:absolute; width:1px; height:1px; overflow:hidden; clip:rect(0 0 0 0); }
  .custom-card textarea { width:100%; min-height:94px; }
</style>
</head>
<body>
<div class="app">
  <header class="card" style="margin-bottom:18px;">
    <h1>CSS3D ã‚¹ãƒ­ãƒƒãƒˆãƒã‚·ãƒ³ - å®Œå…¨ç‰ˆ</h1>
    <p class="muted" style="margin:6px 0 0;">ãƒªãƒ¼ãƒ«æ•°ã‚„ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤ã€é…å½“åˆ¤å®šãƒ»ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç®¡ç†ã¾ã§ã‚’å‚™ãˆãŸæ‹¡å¼µç‰ˆãƒ‡ãƒ¢ã§ã™ã€‚æ¼”å‡ºç”¨ã®ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—å›è»¢ â†’ æœ¬ã‚¹ãƒ”ãƒ³ã®äºŒæ®µåˆ¶å¾¡ã‚’ç¶™æ‰¿ã—ã¤ã¤ã€UI/UX ã‚’å¤§å¹…å¼·åŒ–ã—ã¾ã—ãŸã€‚</p>
  </header>

  <div class="layout">
    <section class="card" aria-label="ã‚²ãƒ¼ãƒ ç”»é¢">
      <div class="panel" style="margin-bottom:16px;">
        <div class="row controls">
          <button id="spin">ã‚¹ãƒ”ãƒ³ (Space)</button>
          <button id="stopAll" disabled>é †æ¬¡ã‚¹ãƒˆãƒƒãƒ— (S)</button>
          <label>ãƒªãƒ¼ãƒ«æ•°
            <select id="reelCount">
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
            </select>
          </label>
          <label>è¡Œæ•°
            <select id="rowCount">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="4">4</option>
            </select>
          </label>
          <label>ãƒ™ãƒƒãƒˆ
            <select id="bet">
              <option value="10">10</option>
              <option value="50">50</option>
              <option value="100">100</option>
            </select>
          </label>
          <label>å›³æŸ„ã‚»ãƒƒãƒˆ
            <select id="symbolsPreset">
              <option value="classic">ã‚¯ãƒ©ã‚·ãƒƒã‚¯</option>
              <option value="fruits">ãƒ•ãƒ«ãƒ¼ãƒ„</option>
              <option value="numbers">ãƒŠãƒ³ãƒãƒ¼</option>
              <option value="custom">ã‚«ã‚¹ã‚¿ãƒ </option>
            </select>
          </label>
          <button id="applySymbols">é©ç”¨</button>
          <button id="reset">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div class="row controls">
          <label>ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—å›è»¢
            <input id="warmup" type="number" min="0" max="20" value="6" style="width:64px;">
          </label>
          <label>æœ¬ã‚¹ãƒ”ãƒ³æ™‚é–“(ms)
            <input id="duration" type="number" min="400" max="6000" value="2200" style="width:80px;">
          </label>
          <label>ãƒªãƒ¼ãƒ«é–“é…å»¶(ms)
            <input id="stagger" type="number" min="0" max="1500" value="220" style="width:80px;">
          </label>
          <label>å›è»¢ä¿‚æ•°
            <input id="turns" type="number" min="2" max="20" value="8" style="width:64px;">
          </label>
          <label>ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤
            <select id="autoplay">
              <option value="0">ã‚ªãƒ•</option>
              <option value="10">10å›</option>
              <option value="25">25å›</option>
              <option value="50">50å›</option>
              <option value="-1">âˆ</option>
            </select>
          </label>
        </div>
        <div class="credits" role="status" aria-live="polite">
          <div>ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ: <strong id="credits">1000</strong></div>
          <div>ãƒ™ãƒƒãƒˆ: <strong id="betDisplay">10</strong></div>
          <div class="autoplay-indicator" id="autoplayStatus">ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤: ã‚ªãƒ•</div>
        </div>
      </div>

      <div class="stage">
        <div class="arm-line"></div>
        <div class="slots" id="slots"></div>
        <div class="stop-buttons" id="stopButtons"></div>
        <div class="result" id="result">â€”</div>
        <div id="announce" role="status" aria-live="assertive"></div>
      </div>
    </section>

    <aside class="card" aria-label="æƒ…å ±ãƒ‘ãƒãƒ«">
      <h2>é…å½“ãƒ†ãƒ¼ãƒ–ãƒ«</h2>
      <div class="paytable" id="paytable"></div>
      <div class="sep" style="height:1px;background:rgba(122,162,247,.16);margin:18px 0;"></div>
      <h2 style="font-size:1.05rem;">å½¹ãƒªã‚¹ãƒˆ</h2>
      <div class="hands" id="handsDisplay"></div>
      <div class="sep" style="height:1px;background:rgba(122,162,247,.16);margin:18px 0;"></div>
      <div class="stats" id="stats">
        <div class="stat"><dt>ç·ã‚¹ãƒ”ãƒ³</dt><dd id="statSpins">0</dd></div>
        <div class="stat"><dt>å‹åˆ©å›æ•°</dt><dd id="statWins">0</dd></div>
        <div class="stat"><dt>å‹ç‡</dt><dd id="statWinRate">0%</dd></div>
        <div class="stat"><dt>æœ€å¤§é…å½“</dt><dd id="statMaxPayout">0</dd></div>
        <div class="stat"><dt>å¹³å‡é…å½“</dt><dd id="statAvgPayout">0</dd></div>
        <div class="stat"><dt>é‚„å…ƒç‡ (RTP)</dt><dd id="statRTP">0%</dd></div>
      </div>
      <div class="sep" style="height:1px;background:rgba(122,162,247,.16);margin:18px 0;"></div>
      <div class="history" aria-live="polite" aria-label="ç›´è¿‘ã®å±¥æ­´">
        <strong style="display:block;margin-bottom:6px;">å±¥æ­´ (æœ€æ–°10ä»¶)</strong>
        <ul id="history"></ul>
      </div>
    </aside>
  </div>

  <section class="card custom-card" aria-label="ã‚«ã‚¹ã‚¿ãƒ è¨­å®š" style="margin:18px auto 0;max-width:1100px;">
    <h2>å›³æŸ„ãƒ»é…å½“ãƒ»å½¹ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º</h2>
    <div class="panel">
      <label>å›³æŸ„ãƒªã‚¹ãƒˆï¼ˆã‚«ãƒ³ãƒ / æ”¹è¡ŒåŒºåˆ‡ã‚Šï¼‰
        <textarea id="customSymbolsInput" placeholder="BAR,7,ğŸ’,ğŸ””,ğŸ‹,ğŸ‰,â­,ğŸ‡,ğŸŠ,ğŸ’,ğŸ€"></textarea>
      </label>
      <label>é…å½“ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆä¾‹: BAR:3=500,4=800ï¼‰
        <textarea id="customPaytableInput" placeholder="BAR:3=500,4=800,5=1500&#10;7:2=120,3=777,4=1200,5=2500"></textarea>
      </label>
      <label>å½¹ãƒªã‚¹ãƒˆï¼ˆä¾‹: åå‰ | ã‚·ãƒ³ãƒœãƒ«åˆ— | é…å½“ï¼‰
        <textarea id="customHandsInput" placeholder="ãƒ©ãƒƒã‚­ãƒ¼7 | 7,7,7 | 2000"></textarea>
      </label>
      <div class="controls">
        <button id="loadCurrentConfig" type="button">ç¾åœ¨ã®å†…å®¹ã‚’èª­ã¿è¾¼ã¿</button>
        <button id="applyCustomConfig" type="button">ã‚«ã‚¹ã‚¿ãƒ è¨­å®šã‚’é©ç”¨</button>
      </div>
      <p class="muted">â€» å›³æŸ„ã¯å·¦ã‹ã‚‰é †ã«ãƒªãƒ¼ãƒ«ã¸é…ç½®ã•ã‚Œã¾ã™ã€‚é…å½“ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã€Œå›³æŸ„:å€‹æ•°=é…å½“ã€ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚å½¹ãƒªã‚¹ãƒˆã¯ã€Œåç§° | ã‚·ãƒ³ãƒœãƒ«1,ã‚·ãƒ³ãƒœãƒ«2,... | é…å½“ã€ã®å½¢å¼ã§1è¡Œãšã¤å…¥åŠ›ã§ãã¾ã™ã€‚</p>
    </div>
  </section>

</div>

<script>
const PRESETS = {
  classic: ["BAR","7","ğŸ’","ğŸ””","ğŸ‹","ğŸ‰","â­","ğŸ‡","ğŸŠ","ğŸ’","ğŸ€"],
  fruits:  ["ğŸ’","ğŸ‹","ğŸ","ğŸ‡","ğŸ“","ğŸ‰","ğŸ","ğŸ¥","ğŸ‘","ğŸŠ","â­","ğŸ’"],
  numbers: ["1","2","3","4","5","6","7","8","9","â˜…","â—","â—‡"],
};

const DEFAULT_PAYTABLE = {
  BAR: {3:500,4:800,5:1500},
  "7": {2:120,3:777,4:1200,5:2500},
  "ğŸ’": {1:5,2:30,3:180,4:360,5:720},
  "ğŸ””": {3:160,4:320,5:640},
  "ğŸ‹": {3:80,4:160,5:320},
  "ğŸ‰": {3:120,4:240,5:480},
  "â­": {3:260,4:520,5:1040},
  "ğŸ’": {3:200,4:400,5:800},
};

const DEFAULT_HANDS = [];

const WEIGHTS = {
  BAR:2,
  "7":1,
  "ğŸ’":10,
  "ğŸ””":6,
  "ğŸ‹":8,
  "ğŸ‰":6,
  "â­":4,
  "ğŸ‡":6,
  "ğŸŠ":6,
  "ğŸ’":4,
  "ğŸ€":3,
  "1":8,"2":8,"3":8,"4":8,"5":7,"6":6,"7":3,"8":5,"9":4,"â˜…":3,"â—":4,"â—‡":4,
};

const state = {
  reelCount: 3,
  rowCount: 3,
  symbols: PRESETS.classic.slice(),
  faces: 14,
  reels: [],
  columnStopButtons: [],
  credits: 1000,
  bet: 10,
  spinning: false,
  autoPlay: {mode:0, remaining:0, active:false},
  lastResults: [],
  history: [],
  stats: {spins:0,wins:0,totalBet:0,totalPayout:0,maxPayout:0},
  paytable: JSON.parse(JSON.stringify(DEFAULT_PAYTABLE)),
  hands: JSON.parse(JSON.stringify(DEFAULT_HANDS)),
};

const $slots = document.getElementById('slots');
const $stopButtons = document.getElementById('stopButtons');
const $rowCount = document.getElementById('rowCount');
const $result = document.getElementById('result');
const $credits = document.getElementById('credits');
const $betDisplay = document.getElementById('betDisplay');
const $paytable = document.getElementById('paytable');
const $history = document.getElementById('history');
const $announce = document.getElementById('announce');
const $autoplayStatus = document.getElementById('autoplayStatus');
const $handsDisplay = document.getElementById('handsDisplay');
const $customSymbolsInput = document.getElementById('customSymbolsInput');
const $customPaytableInput = document.getElementById('customPaytableInput');
const $customHandsInput = document.getElementById('customHandsInput');
const btnLoadConfig = document.getElementById('loadCurrentConfig');
const btnApplyCustom = document.getElementById('applyCustomConfig');

const btnSpin = document.getElementById('spin');
const btnStopAll = document.getElementById('stopAll');

function weightedRandomSymbol(){
  const pool = state.symbols;
  let total = 0;
  pool.forEach(sym=>{
    const weightKey = WEIGHTS[sym] ?? 5;
    total += weightKey;
  });
  let r = Math.random()*total;
  for(const sym of pool){
    const weightKey = WEIGHTS[sym] ?? 5;
    r -= weightKey;
    if(r <= 0){ return sym; }
  }
  return pool[pool.length-1];
}

function renderPaytable(){
  $paytable.innerHTML = '';
  const table = state.paytable;
  const relevantSymbols = state.symbols.filter(sym=>table[sym]);
  const entries = relevantSymbols.length ? relevantSymbols : Object.keys(table);
  Array.from(new Set(entries)).forEach(symbol=>{
    const payouts = table[symbol];
    if(!payouts) return;
    const wrap = document.createElement('div');
    const title = document.createElement('h3');
    title.textContent = `${symbol}`;
    wrap.appendChild(title);
    const list = document.createElement('ul');
    Object.keys(payouts).sort((a,b)=>Number(b)-Number(a)).forEach(k=>{
      const li = document.createElement('li');
      if(Number(k) === 1){
        li.textContent = `ä»»æ„ä½ç½®ã«${k}å€‹ â†’ ${payouts[k]} ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ`;
      } else {
        li.textContent = `${k}å€‹æƒã„ â†’ ${payouts[k]} ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ`;
      }
      list.appendChild(li);
    });
    wrap.appendChild(list);
    $paytable.appendChild(wrap);
  });
  if($paytable.children.length === 0){
    const empty = document.createElement('p');
    empty.className = 'muted';
    empty.textContent = 'é…å½“ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚';
    $paytable.appendChild(empty);
  }
}

function renderHands(){
  $handsDisplay.innerHTML = '';
  if(!state.hands.length){
    const empty = document.createElement('p');
    empty.className = 'muted';
    empty.textContent = 'ã‚«ã‚¹ã‚¿ãƒ å½¹ã¯æœªè¨­å®šã§ã™ã€‚';
    $handsDisplay.appendChild(empty);
    return;
  }
  state.hands.forEach(hand=>{
    const item = document.createElement('div');
    item.className = 'hands-item';
    const title = document.createElement('strong');
    title.textContent = hand.name || 'åç§°æœªè¨­å®š';
    const symbols = Array.isArray(hand.symbols) ? hand.symbols.join(' | ') : '';
    const desc = document.createElement('span');
    desc.textContent = `${symbols} â†’ ${hand.payout} ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆ`;
    item.appendChild(title);
    item.appendChild(desc);
    $handsDisplay.appendChild(item);
  });
}

function parseSymbolList(raw){
  return raw.split(/[\s,ã€\/]+/).map(s=>s.trim()).filter(Boolean);
}

function parsePaytableInput(raw){
  const text = raw.trim();
  if(!text) return null;
  try {
    const parsed = JSON.parse(text);
    if(parsed && typeof parsed === 'object' && !Array.isArray(parsed)){
      const normalized = {};
      Object.entries(parsed).forEach(([symbol, payouts])=>{
        if(!payouts || typeof payouts !== 'object') return;
        const map = {};
        Object.entries(payouts).forEach(([countKey, value])=>{
          const count = Number(countKey);
          const payout = Number(value);
          if(!Number.isNaN(count) && !Number.isNaN(payout) && count>0){
            map[count] = payout;
          }
        });
        if(Object.keys(map).length){
          normalized[symbol] = map;
        }
      });
      return Object.keys(normalized).length ? normalized : null;
    }
  } catch(err) {
    // fallback to manual parsing
  }
  const table = {};
  text.split(/\n+/).forEach(line=>{
    const trimmed = line.trim();
    if(!trimmed) return;
    const [symbolPart, valuesPart] = trimmed.split(':');
    if(!valuesPart) return;
    const symbol = symbolPart.trim();
    if(!symbol) return;
    const entries = valuesPart.split(',');
    const payoutMap = table[symbol] || {};
    entries.forEach(entry=>{
      const [countStr, payoutStr] = entry.split('=');
      const count = Number(countStr);
      const payout = Number(payoutStr);
      if(!Number.isNaN(count) && !Number.isNaN(payout) && count>0){
        payoutMap[count] = payout;
      }
    });
    if(Object.keys(payoutMap).length){
      table[symbol] = payoutMap;
    }
  });
  return Object.keys(table).length ? table : null;
}

function parseHandsInput(raw){
  const text = raw.trim();
  if(!text) return [];
  try {
    const parsed = JSON.parse(text);
    if(Array.isArray(parsed)){
      return parsed.map(item=>({
        name: item.name || 'åç§°æœªè¨­å®š',
        symbols: Array.isArray(item.symbols) ? item.symbols.map(String) : [],
        payout: Number(item.payout) || 0,
      })).filter(item=>item.symbols.length && item.payout>0);
    }
  } catch(err) {
    // fallback to manual parsing
  }
  const hands = [];
  text.split(/\n+/).forEach(line=>{
    const parts = line.split('|').map(p=>p.trim()).filter(Boolean);
    if(parts.length < 2) return;
    const name = parts[0];
    const symbolList = parts[1].split(',').map(s=>s.trim()).filter(Boolean);
    const payout = Number(parts[2] ?? '0');
    if(symbolList.length && payout>0){
      hands.push({name, symbols:symbolList, payout});
    }
  });
  return hands;
}

function formatPaytable(table){
  return Object.entries(table).map(([symbol, payouts])=>{
    const entries = Object.entries(payouts)
      .sort((a,b)=>Number(a[0]) - Number(b[0]))
      .map(([count, value])=>`${count}=${value}`)
      .join(',');
    return `${symbol}:${entries}`;
  }).join('\n');
}

function formatHands(hands){
  return hands.map(hand=>{
    const name = hand.name || 'åç§°æœªè¨­å®š';
    const symbols = Array.isArray(hand.symbols) ? hand.symbols.join(',') : '';
    const payout = hand.payout ?? 0;
    return `${name} | ${symbols} | ${payout}`;
  }).join('\n');
}

function syncCustomInputs(){
  $customSymbolsInput.value = state.symbols.join(',');
  $customPaytableInput.value = formatPaytable(state.paytable);
  $customHandsInput.value = formatHands(state.hands);
}

function buildReels(){
  $slots.innerHTML='';
  state.reels = [];
  state.columnStopButtons = [];
  const facesCount = Math.max(12, state.symbols.length*1.5|0);
  state.faces = facesCount;

  for(let row=0; row<state.rowCount; row++){
    const rowWrap = document.createElement('div');
    rowWrap.className = 'slot-row';
    const rowReels = [];

    for(let col=0; col<state.reelCount; col++){
      const wrap = document.createElement('div');
      wrap.className='reel-wrap';
      const reel = document.createElement('div');
      reel.className='reel';
      wrap.appendChild(reel);
      rowWrap.appendChild(wrap);

      const H = parseFloat(getComputedStyle(wrap).height);
      const step = 360 / facesCount;
      const radius = H/2 / Math.tan(Math.PI / facesCount);

      const faces=[];
      const indexMap = new Map();
      for(let i=0;i<facesCount;i++){
        const face = document.createElement('div');
        face.className='face';
        const sym = state.symbols[i % state.symbols.length];
        face.textContent = sym;
        face.setAttribute('data-symbol', sym);
        const rot=i*step;
        face.style.transform=`rotateX(${rot}deg) translateZ(${radius.toFixed(2)}px)`;
        reel.appendChild(face);
        faces.push(face);
        if(!indexMap.has(sym)) indexMap.set(sym, []);
        indexMap.get(sym).push(i);
      }

      const reelObj = {wrap,reel,faces,step,radius,turn:0,spinning:false,promise:null,finishNow:null,indexMap,targetFace:0,row,col};
      rowReels.push(reelObj);
    }

    state.reels.push(rowReels);
    $slots.appendChild(rowWrap);
  }

  $stopButtons.innerHTML='';
  const stopLabels = ['å·¦','ä¸­','å³','ç¬¬4','ç¬¬5','ç¬¬6','ç¬¬7'];
  for(let col=0; col<state.reelCount; col++){
    const btn = document.createElement('button');
    const label = stopLabels[col] || `#${col+1}`;
    btn.textContent = `${label}ã‚¹ãƒˆãƒƒãƒ—`;
    btn.disabled = true;
    btn.onclick = ()=>{
      stopColumn(col);
    };
    $stopButtons.appendChild(btn);
    state.columnStopButtons.push(btn);
  }
}

function forEachReel(callback){
  state.reels.forEach((rowArr, rowIdx)=>{
    rowArr.forEach((reel, colIdx)=>{
      callback(reel, rowIdx, colIdx);
    });
  });
}

function getColumnReels(colIdx){
  return state.reels.map(row=>row[colIdx]).filter(Boolean);
}

function stopColumn(colIdx){
  getColumnReels(colIdx).forEach(reel=>{
    if(reel && reel.finishNow){ reel.finishNow(); }
  });
}

function updateCreditsDisplay(){
  $credits.textContent = state.credits;
  $betDisplay.textContent = state.bet;
  btnSpin.disabled = state.spinning || state.credits < state.bet;
}

function updateAutoplayStatus(){
  const mode = state.autoPlay.mode;
  if(!state.autoPlay.active || mode === 0){
    $autoplayStatus.textContent = 'ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤: ã‚ªãƒ•';
    return;
  }
  if(mode === -1){
    $autoplayStatus.textContent = 'ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤: âˆ é€²è¡Œä¸­';
  } else {
    $autoplayStatus.textContent = `ã‚ªãƒ¼ãƒˆãƒ—ãƒ¬ã‚¤æ®‹ã‚Š: ${state.autoPlay.remaining}`;
  }
}

function updateStatsDisplay(){
  const {spins,wins,totalBet,totalPayout,maxPayout} = state.stats;
  document.getElementById('statSpins').textContent = spins;
  document.getElementById('statWins').textContent = wins;
  document.getElementById('statWinRate').textContent = spins ? `${(wins/spins*100).toFixed(1)}%` : '0%';
  document.getElementById('statMaxPayout').textContent = maxPayout;
  document.getElementById('statAvgPayout').textContent = spins ? (totalPayout/spins).toFixed(1) : '0';
  document.getElementById('statRTP').textContent = totalBet ? `${(totalPayout/totalBet*100).toFixed(1)}%` : '0%';
}

function updateHistory(){
  $history.innerHTML='';
  state.history.slice(-10).reverse().forEach(entry=>{
    const li = document.createElement('li');
    const resultSpan = document.createElement('span');
    const linesArray = Array.isArray(entry.results) ? entry.results.map(row=>row.join(' | ')) : [];
    const lines = linesArray.length ? linesArray.join(' / ') : 'â€”';
    const labelText = entry.labels && entry.labels.length ? ` (${entry.labels.join(', ')})` : '';
    resultSpan.textContent = `${lines}${labelText}`;
    const payoutSpan = document.createElement('span');
    payoutSpan.textContent = entry.payout ? `+${entry.payout}` : '0';
    if(entry.payout>0){ payoutSpan.classList.add('win'); }
    li.appendChild(resultSpan);
    li.appendChild(payoutSpan);
    $history.appendChild(li);
  });
}

function randomFaceIndexForSymbol(reel, symbol){
  const indices = reel.indexMap.get(symbol);
  if(!indices || indices.length === 0){
    return Math.floor(Math.random()*reel.faces.length);
  }
  return indices[Math.floor(Math.random()*indices.length)];
}

function animateReelTwoPhase(reel, warmupTurns, finalTargetDeg, finalDuration, delay){
  reel.spinning = true;
  let resolveFn; reel.promise = new Promise(res=>resolveFn=res);
  let skipWarmup = false;
  let accelerate = false;
  let accelerateApplied = false;
  let mainStarted = false;
  let delayStart = null;
  let warmupStart = null;
  let finalStart = null;
  let currentDuration = finalDuration;
  const startDeg = reel.turn;
  const warmupTarget = startDeg - 360 * warmupTurns;
  const warmupPerTurnMs = 200;
  const warmupDuration = Math.max(200, warmupTurns * warmupPerTurnMs);

  reel.finishNow = ()=>{
    if(!mainStarted){
      skipWarmup = true;
    } else {
      accelerate = true;
    }
  };

  function mainStep(ts){
    if(finalStart === null){ finalStart = ts; }
    if(accelerate && !accelerateApplied){
      const elapsed = ts - finalStart;
      const progress = Math.min(1, elapsed / currentDuration);
      currentDuration = Math.min(currentDuration, 420);
      finalStart = ts - progress * currentDuration;
      accelerateApplied = true;
    }
    const elapsed = ts - finalStart;
    const progress = Math.min(1, elapsed / currentDuration);
    const eased = 1 - Math.pow(1-progress,3);
    const deg = startDeg + (finalTargetDeg - startDeg) * eased;
    reel.turn = deg;
    reel.reel.style.transform = `rotateX(${deg}deg)`;
    if(progress < 1){
      reel.raf = requestAnimationFrame(mainStep);
    } else {
      reel.spinning = false;
      reel.turn = finalTargetDeg;
      reel.reel.style.transform = `rotateX(${finalTargetDeg}deg)`;
      reel.finishNow = null;
      resolveFn();
    }
  }

  function warmupStep(ts){
    if(skipWarmup){
      mainStarted = true;
      reel.turn = startDeg;
      reel.reel.style.transform = `rotateX(${startDeg}deg)`;
      reel.raf = requestAnimationFrame(mainStep);
      return;
    }
    if(warmupStart === null){ warmupStart = ts; }
    const elapsed = ts - warmupStart;
    const progress = Math.min(1, elapsed / warmupDuration);
    const deg = startDeg + (warmupTarget - startDeg) * progress;
    reel.turn = deg;
    reel.reel.style.transform = `rotateX(${deg}deg)`;
    if(progress < 1){
      reel.raf = requestAnimationFrame(warmupStep);
    } else {
      mainStarted = true;
      reel.turn = startDeg;
      reel.reel.style.transform = `rotateX(${startDeg}deg)`;
      reel.raf = requestAnimationFrame(mainStep);
    }
  }

  function startAnimation(ts){
    if(delayStart === null){ delayStart = ts; }
    if(delay && ts - delayStart < delay){
      reel.raf = requestAnimationFrame(startAnimation);
      return;
    }
    if(warmupTurns>0){
      reel.raf = requestAnimationFrame(warmupStep);
    } else {
      mainStarted = true;
      finalStart = null;
      reel.raf = requestAnimationFrame(mainStep);
    }
  }

  reel.raf = requestAnimationFrame(startAnimation);
}

function generateSpinResults(){
  const grid = [];
  for(let row=0; row<state.rowCount; row++){
    const rowResults = [];
    for(let col=0; col<state.reelCount; col++){
      rowResults.push(weightedRandomSymbol());
    }
    grid.push(rowResults);
  }
  return grid;
}

function computeTargets(results, turns, duration, stagger, warmup){
  const targets = [];
  results.forEach((rowResults, rowIdx)=>{
    rowResults.forEach((symbol, colIdx)=>{
      const reel = state.reels[rowIdx][colIdx];
      const faceIdx = randomFaceIndexForSymbol(reel, symbol);
      const baseTarget = -faceIdx * reel.step;
      const extraTurns = turns + colIdx + rowIdx;
      const targetDeg = baseTarget - 360 * extraTurns;
      reel.targetFace = faceIdx;
      targets.push({
        targetDeg,
        reel,
        faceIdx,
        symbol,
        duration: duration + colIdx*150 + rowIdx*90,
        delay: stagger*colIdx + rowIdx*120,
        warmup,
      });
    });
  });
  return targets;
}

function evaluateLine(results){
  if(!Array.isArray(results) || results.length === 0){
    return {payout:0, highlightIndices:new Set(), label:''};
  }

  const counts = {};
  results.forEach(sym=>{
    counts[sym] = (counts[sym]||0)+1;
  });
  const allSame = results.every(s=>s===results[0]);
  const highlightIndices = new Set();
  let payout = 0;
  let winningLabel = '';

  const firstSymbol = results[0];
  let run = 1;
  for(let i=1;i<results.length;i++){
    if(results[i] === firstSymbol){ run++; }
    else break;
  }
  if(state.paytable[firstSymbol]){
    const pay = state.paytable[firstSymbol][run];
    if(pay){
      payout = Math.max(payout, pay);
      highlightIndices.clear();
      for(let i=0;i<run;i++){ highlightIndices.add(i); }
      winningLabel = `${firstSymbol} ${run}å€‹æƒã„`;
    }
  }

  Object.entries(state.paytable).forEach(([sym, table])=>{
    if(table[1]){
      const count = counts[sym]||0;
      const keys = Object.keys(table).map(Number).filter(k=>k<=count);
      if(keys.length){
        const best = keys.reduce((a,b)=>a>b?a:b);
        if(table[best] > payout){
          payout = table[best];
          highlightIndices.clear();
          results.forEach((s,i)=>{ if(s===sym) highlightIndices.add(i); });
          winningLabel = `${sym} ${best}å€‹ãƒ’ãƒƒãƒˆ`;
        }
      }
    }
  });

  if(allSame && state.paytable[firstSymbol]){
    const pay = state.paytable[firstSymbol][results.length];
    if(pay && pay >= payout){
      payout = pay;
      highlightIndices.clear();
      results.forEach((s,i)=>highlightIndices.add(i));
      winningLabel = `${firstSymbol} å…¨é¢æƒã„`;
    }
  }

  state.hands.forEach(hand=>{
    if(!hand || !Array.isArray(hand.symbols) || !hand.symbols.length) return;
    if(hand.symbols.length > results.length) return;
    const matched = hand.symbols.every((sym, idx)=>{
      if(sym === '*' || sym === 'ANY') return true;
      return results[idx] === sym;
    });
    if(matched && Number(hand.payout) > payout){
      payout = Number(hand.payout);
      highlightIndices.clear();
      hand.symbols.forEach((_, idx)=>highlightIndices.add(idx));
      winningLabel = hand.name || hand.symbols.join(',');
    }
  });

  return {payout, highlightIndices, label: winningLabel};
}

function evaluateResults(grid){
  let totalPayout = 0;
  const highlightKeys = new Set();
  const labels = [];

  grid.forEach((rowResults, rowIdx)=>{
    const info = evaluateLine(rowResults);
    if(info.payout>0){
      totalPayout += info.payout;
      info.highlightIndices.forEach(colIdx=>{
        highlightKeys.add(`${rowIdx}:${colIdx}`);
      });
      labels.push(info.label ? `è¡Œ${rowIdx+1}: ${info.label}` : `è¡Œ${rowIdx+1}`);
    }
  });

  return {payout: totalPayout, highlightKeys, labels};
}

function highlightFaces(highlights){
  forEachReel(reel=>{
    reel.faces.forEach(face=>face.classList.remove('winning'));
  });
  if(highlights.size === 0) return;
  forEachReel((reel, rowIdx, colIdx)=>{
    if(!highlights.has(`${rowIdx}:${colIdx}`)) return;
    const faceIdx = ((reel.targetFace % reel.faces.length)+reel.faces.length)%reel.faces.length;
    const face = reel.faces[faceIdx];
    if(face){ face.classList.add('winning'); }
  });
}

function clearHighlights(){
  forEachReel(reel=>{
    reel.faces.forEach(face=>face.classList.remove('winning'));
  });
}

function finishSpin(results, payoutInfo){
  state.spinning = false;
  btnStopAll.disabled = true;
  state.columnStopButtons.forEach(btn=>btn.disabled = true);
  highlightFaces(payoutInfo.highlightKeys);

  state.stats.spins += 1;
  state.stats.totalBet += state.bet;
  const formattedLines = results.map(row=>`[ ${row.join(' | ')} ]`);
  let message = `çµæœ: ${formattedLines.join(' / ')}`;
  const labels = Array.isArray(payoutInfo.labels) ? payoutInfo.labels : [];
  const labelText = labels.length ? ` (${labels.join(', ')})` : '';
  if(payoutInfo.payout>0){
    state.stats.wins += 1;
    state.stats.totalPayout += payoutInfo.payout;
    if(payoutInfo.payout > state.stats.maxPayout) state.stats.maxPayout = payoutInfo.payout;
    state.credits += payoutInfo.payout;
    message += ` â†’ ${payoutInfo.payout} ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç²å¾—!${labelText}`;
    const announceBody = labels.length ? `${labels.join('ã€')}ãŒæˆç«‹ã—` : 'å½¹ãŒæˆç«‹ã—';
    $announce.textContent = `ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™! ${formattedLines.join(' / ')} ${announceBody}ã€${payoutInfo.payout}ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆç²å¾—ã§ã™ã€‚`;
  } else {
    $announce.textContent = `çµæœã¯ ${formattedLines.join(' / ')} ã§ã™ã€‚`;
  }
  $result.textContent = message;
  state.history.push({
    results: results.map(row=>row.slice()),
    payout: payoutInfo.payout,
    labels: labels.slice(),
  });
  updateHistory();
  updateCreditsDisplay();
  updateStatsDisplay();

  if(state.credits <= 0){
    $result.textContent += ' ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãŒå°½ãã¾ã—ãŸâ€¦ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚';
    btnSpin.disabled = true;
    stopAutoplay();
  }

  if(state.autoPlay.active){
    if(state.autoPlay.mode !== -1){
      state.autoPlay.remaining -= 1;
      if(state.autoPlay.remaining <= 0){
        stopAutoplay();
        updateAutoplayStatus();
        return;
      }
    }
    updateAutoplayStatus();
    setTimeout(()=>{
      startSpin();
    }, 600);
  }
}

function stopAutoplay(){
  state.autoPlay.active = false;
  state.autoPlay.mode = 0;
  state.autoPlay.remaining = 0;
  document.getElementById('autoplay').value = '0';
  updateAutoplayStatus();
}

function startSpin(){
  if(state.spinning) return;
  if(state.credits < state.bet){
    $result.textContent = 'ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆä¸è¶³ã§ã™ã€‚ãƒ™ãƒƒãƒˆé¡ã‚’ä¸‹ã’ã‚‹ã‹ã€ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚';
    stopAutoplay();
    return;
  }
  clearHighlights();
  state.spinning = true;
  btnSpin.disabled = true;
  btnStopAll.disabled = false;
  state.columnStopButtons.forEach(btn=>btn.disabled = false);
  state.credits -= state.bet;
  const turns = Math.max(2, Math.min(20, Number(document.getElementById('turns').value)||8));
  const duration = Math.max(400, Math.min(6000, Number(document.getElementById('duration').value)||2200));
  const stagger = Math.max(0, Math.min(1500, Number(document.getElementById('stagger').value)||220));
  const warmup = Math.max(0, Math.min(20, Number(document.getElementById('warmup').value)||6));

  updateCreditsDisplay();
  $result.textContent = 'ã‚¹ãƒ”ãƒ³ä¸­â€¦';

  const results = generateSpinResults();
  state.lastResults = results.map(row=>row.slice());
  const targets = computeTargets(results, turns, duration, stagger, warmup);
  const promises = [];
  targets.forEach(t=>{
    animateReelTwoPhase(t.reel, warmup, t.targetDeg, t.duration, t.delay);
    if(t.reel.promise){ promises.push(t.reel.promise); }
  });
  Promise.all(promises).then(()=>{
    const payoutInfo = evaluateResults(results);
    finishSpin(results, payoutInfo);
  });
}

function stopSequential(){
  state.columnStopButtons.forEach((_, colIdx)=>{
    setTimeout(()=>{
      stopColumn(colIdx);
    }, colIdx * 200);
  });
  btnStopAll.disabled = true;
}

function handleAutoplayChange(value){
  if(state.spinning){
    $result.textContent = 'ç¾åœ¨ã‚¹ãƒ”ãƒ³ä¸­ã§ã™ã€‚ã‚ªãƒ¼ãƒˆè¨­å®šå¤‰æ›´ã¯å®Œäº†å¾Œã«é©ç”¨ã•ã‚Œã¾ã™ã€‚';
    return;
  }
  const mode = Number(value);
  if(mode === 0){
    stopAutoplay();
    return;
  }
  state.autoPlay.mode = mode;
  state.autoPlay.active = true;
  state.autoPlay.remaining = mode === -1 ? Infinity : mode;
  updateAutoplayStatus();
  startSpin();
}

function resetGame(){
  state.credits = 1000;
  state.stats = {spins:0,wins:0,totalBet:0,totalPayout:0,maxPayout:0};
  state.history = [];
  stopAutoplay();
  clearHighlights();
  updateHistory();
  updateStatsDisplay();
  updateCreditsDisplay();
  $result.textContent = 'ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã‚¹ãƒ”ãƒ³ã—ã¦ã¿ã¾ã—ã‚‡ã†!';
}

// ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
btnSpin.addEventListener('click', ()=>{
  if(state.autoPlay.active && state.autoPlay.mode !== -1){
    stopAutoplay();
  }
  startSpin();
});
btnStopAll.addEventListener('click', stopSequential);

document.getElementById('reelCount').addEventListener('change', (e)=>{
  state.reelCount = Number(e.target.value);
  buildReels();
  clearHighlights();
});

$rowCount.addEventListener('change', (e)=>{
  state.rowCount = Math.max(1, Number(e.target.value));
  buildReels();
  clearHighlights();
});

document.getElementById('bet').addEventListener('change', (e)=>{
  state.bet = Number(e.target.value);
  updateCreditsDisplay();
});

const symbolsSelect = document.getElementById('symbolsPreset');
document.getElementById('applySymbols').addEventListener('click', ()=>{
  const presetKey = symbolsSelect.value;
  if(presetKey === 'custom'){
    const list = parseSymbolList($customSymbolsInput.value);
    if(list.length < 2){
      alert('ã‚«ã‚¹ã‚¿ãƒ å›³æŸ„ã¯2ã¤ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    state.symbols = list;
  } else {
    state.symbols = PRESETS[presetKey].slice();
    state.paytable = JSON.parse(JSON.stringify(DEFAULT_PAYTABLE));
    state.hands = JSON.parse(JSON.stringify(DEFAULT_HANDS));
  }
  buildReels();
  renderPaytable();
  renderHands();
  syncCustomInputs();
  clearHighlights();
});

document.getElementById('autoplay').addEventListener('change', (e)=>{
  handleAutoplayChange(e.target.value);
});

document.getElementById('reset').addEventListener('click', ()=>{
  resetGame();
});

btnLoadConfig.addEventListener('click', ()=>{
  syncCustomInputs();
});

btnApplyCustom.addEventListener('click', ()=>{
  if(state.spinning){
    alert('ã‚¹ãƒ”ãƒ³ä¸­ã¯è¨­å®šã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚');
    return;
  }
  if(state.autoPlay.active){
    stopAutoplay();
  }
  const symbols = parseSymbolList($customSymbolsInput.value);
  if(symbols.length < 2){
    alert('å›³æŸ„ã¯2ã¤ä»¥ä¸Šå…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
    return;
  }
  const paytableText = $customPaytableInput.value;
  let paytable;
  if(paytableText.trim()){
    paytable = parsePaytableInput(paytableText);
    if(!paytable){
      alert('é…å½“ãƒ†ãƒ¼ãƒ–ãƒ«ã®å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ä¾‹: BAR:3=500,4=800');
      return;
    }
  } else {
    paytable = JSON.parse(JSON.stringify(DEFAULT_PAYTABLE));
  }
  const hands = parseHandsInput($customHandsInput.value);

  state.symbols = symbols;
  state.paytable = paytable;
  state.hands = hands;
  symbolsSelect.value = 'custom';
  buildReels();
  renderPaytable();
  renderHands();
  syncCustomInputs();
  clearHighlights();
  updateCreditsDisplay();
  $result.textContent = 'ã‚«ã‚¹ã‚¿ãƒ è¨­å®šã‚’é©ç”¨ã—ã¾ã—ãŸã€‚';
});

// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
window.addEventListener('keydown', (e)=>{
  if(e.repeat) return;
  if(e.code === 'Space'){ e.preventDefault(); btnSpin.click(); }
  if(e.key === 's' || e.key === 'S'){ e.preventDefault(); btnStopAll.click(); }
  const digit = Number(e.key);
  if(Number.isInteger(digit) && digit>=1){
    const idx = digit - 1;
    if(idx < state.reelCount){
      e.preventDefault();
      stopColumn(idx);
    }
  }
  if(e.key === 'a' || e.key === 'A'){
    const select = document.getElementById('autoplay');
    if(state.autoPlay.active){
      stopAutoplay();
      select.value = '0';
    } else {
      select.value = '10';
      handleAutoplayChange('10');
    }
  }
});

// ãƒ¢ãƒã‚¤ãƒ«å‘ã‘: ãƒªãƒ¼ãƒ«ã‚¿ãƒƒãƒ—ã§å€‹åˆ¥åœæ­¢
$slots.addEventListener('click', (e)=>{
  for(let rowIdx=0; rowIdx<state.reels.length; rowIdx++){
    for(let colIdx=0; colIdx<state.reels[rowIdx].length; colIdx++){
      const reel = state.reels[rowIdx][colIdx];
      if(reel && reel.reel.contains(e.target)){
        if(reel.finishNow){ reel.finishNow(); }
        return;
      }
    }
  }
});

function init(){
  $rowCount.value = String(state.rowCount);
  renderPaytable();
  renderHands();
  buildReels();
  updateCreditsDisplay();
  updateStatsDisplay();
  updateHistory();
  updateAutoplayStatus();
  syncCustomInputs();
  $result.textContent = 'ã‚¹ãƒ”ãƒ³ã—ã¦éŠã‚“ã§ã¿ã¾ã—ã‚‡ã†!';
}

init();
</script>
</body>
</html>
